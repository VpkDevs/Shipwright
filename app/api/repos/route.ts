import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { GitHubClient } from "@/lib/github";
import { z } from "zod";

export async function GET() {
  const session = await getServerSession(authOptions);

  if (!session?.user || !(session.user as { accessToken?: string }).accessToken) {
    return Response.json({ error: "Unauthorized" }, { status: 401 });
  }

  const token = (session.user as { accessToken?: string }).accessToken!;
  const client = new GitHubClient(token);

  try {
    const repos = await client.getUserRepos();
    return Response.json(repos);
  } catch (error) {
    console.error("Failed to fetch repos:", error);
    return Response.json(
      { error: "Failed to fetch repositories" },
      { status: 500 }
    );
  }
}

const createPRSchema = z.object({
  action: z.literal("create_pr"),
  owner: z.string().min(1),
  repo: z.string().min(1),
  files: z.array(
    z.object({
      path: z.string().min(1),
      content: z.string(),
    })
  ).min(1),
});

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);

  if (!session?.user || !(session.user as { accessToken?: string }).accessToken) {
    return Response.json({ error: "Unauthorized" }, { status: 401 });
  }

  let body: unknown;
  try {
    body = await request.json();
  } catch {
    return Response.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const parsed = createPRSchema.safeParse(body);
  if (!parsed.success) {
    return Response.json({ error: "Invalid request parameters" }, { status: 400 });
  }

  const { owner, repo, files } = parsed.data;
  const token = (session.user as { accessToken?: string }).accessToken!;
  const client = new GitHubClient(token);

  const branchName = `shipwright/ship-${Date.now()}`;

  // Try main, then master as the base branch
  let branch = await client.createBranch(owner, repo, branchName, "main");
  if (!branch) {
    branch = await client.createBranch(owner, repo, branchName, "master");
  }
  if (!branch) {
    return Response.json(
      { error: "Could not create branch â€” ensure the repository has a default branch (main or master)." },
      { status: 500 }
    );
  }

  // Commit each file to the new branch
  for (const file of files) {
    const result = await client.createOrUpdateFile(
      owner,
      repo,
      file.path,
      file.content,
      branchName,
      `chore: add ${file.path} via Shipwright`
    );
    if (!result) {
      return Response.json(
        { error: `Failed to commit ${file.path} to branch.` },
        { status: 500 }
      );
    }
  }

  // Create pull request
  const pr = await client.createPullRequest(
    owner,
    repo,
    "ðŸš€ Ship: Add AI-generated deployment configs",
    `## Generated by [Shipwright](https://shipwright.dev)\n\nThis PR adds the following files generated by Shipwright AI:\n\n${files.map((f) => `- \`${f.path}\``).join("\n")}\n\n### What's included\n- **README.md** â€” AI-generated documentation from your actual codebase\n- **vercel.json** â€” Production deployment config\n- **.env.example** â€” Documented environment variables\n\n> Generated with Shipwright Â· [shipwright.dev](https://shipwright.dev)`,
    branchName,
    "main"
  );

  // Try master if main PR fails
  if (!pr) {
    const prMaster = await client.createPullRequest(
      owner,
      repo,
      "ðŸš€ Ship: Add AI-generated deployment configs",
      `## Generated by [Shipwright](https://shipwright.dev)\n\nThis PR adds the following files:\n\n${files.map((f) => `- \`${f.path}\``).join("\n")}`,
      branchName,
      "master"
    );
    if (!prMaster) {
      return Response.json(
        { error: "Files committed but PR creation failed. Check the repository for the new branch." },
        { status: 500 }
      );
    }
    return Response.json({ url: prMaster.html_url, branch: branchName });
  }

  return Response.json({ url: pr.html_url, branch: branchName });
}
